import google.generativeai as genai
from agent.ToolCall_Agent.agent import ToolCallAgent
import os


# Configure Gemini API
api_key = os.environ.get("GOOGLE_API_KEY")
if not api_key:
    raise ValueError("GOOGLE_API_KEY environment variable not set")
genai.configure(api_key=api_key)


class GeminiLLM:
    """Wrapper for Gemini LLM to work with ToolCallAgent."""
    def __init__(self, model_name="gemini-2.0-flash-lite"):
        self.model_name = model_name
        self.model = genai.GenerativeModel(model_name)
    def generate_response(self, prompt):
        """Generate response from Gemini."""
        response = self.model.generate_content(prompt)
        return response.text


# Define tool functions
def calculator(expression):
    """Calculate mathematical expressions."""
    try:
        result = eval(expression)
        return f"The result is: {result}"
    except Exception as e:
        return f"Error calculating: {str(e)}"


def search(query, max_results="5"):
    """Simulate a search function (placeholder)."""
    # In real implementation, you would use an actual search API
    return f"Search results for '{query}' (showing top {max_results} results): [Result 1, Result 2, Result 3...]"


def weather(city):
    """Get weather for a city (placeholder)."""
    # In real implementation, you would use a weather API
    return f"Weather in {city}: Sunny, 25°C"


def translator(text, target_language):
    """Translate text to target language (placeholder)."""
    # In real implementation, you would use a translation API
    return f"Translated '{text}' to {target_language}: [Translation result]"


def generate_report(results):
    """Generate a markdown report of test results."""
    from datetime import datetime
    
    report = f"""# ToolCall Agent Test Report

**Date:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}  
**Model:** Gemini 2.0 Flash  
**Total Tests:** {len(results)}  
**Passed:** {sum(1 for r in results if r['status'] == 'SUCCESS')}  
**Failed:** {sum(1 for r in results if r['status'] == 'FAILED')}  

---

## Test Results Summary

| Test # | Status | Query |
|--------|--------|-------|
"""
    
    for result in results:
        status_icon = "✅" if result['status'] == 'SUCCESS' else "❌"
        report += f"| {result['test_num']} | {status_icon} {result['status']} | {result['query'][:50]}{'...' if len(result['query']) > 50 else ''} |\n"
    
    report += "\n---\n\n## Detailed Results\n\n"
    
    for result in results:
        status_icon = "✅" if result['status'] == 'SUCCESS' else "❌"
        report += f"### Test {result['test_num']}: {status_icon} {result['status']}\n\n"
        report += f"**Query:**\n```\n{result['query']}\n```\n\n"
        report += f"**Result:**\n```\n{result['result']}\n```\n\n"
        report += "---\n\n"
    
    report += """## Analysis

### Key Findings:
- The agent successfully handles single tool calls
- Multi-tool queries are processed sequentially
- Error handling works when incorrect parameters are used
- The agent can chain multiple tool results together

### Performance:
- Response time varies based on LLM latency
- Tool execution is fast
- The agent typically needs 2-3 iterations per query

### Recommendations:
1. Provide clear parameter names in tool descriptions
2. Use verbose mode for debugging
3. Set appropriate max_iterations for complex queries
4. Handle tool errors gracefully with clear error messages

---

*Generated by ToolCall Agent Test Suite*
"""
    
    # Write report to file
    with open("test_report.md", "w", encoding="utf-8") as f:
        f.write(report)
    
    print(f"\n{'=' * 80}")
    print(f"Report generated: test_report.md")
    print(f"{'=' * 80}\n")


# Create and configure the agent
def main():
    # Initialize LLM
    llm = GeminiLLM()
    
    # Create agent with verbose mode
    agent = ToolCallAgent(verbose=False)
    
    # Add LLM
    agent.add_llm(llm)
    
    # Add tools
    agent.add_tool(
        name="calculator",
        description="Performs mathematical calculations. Parameter: 'expression' (string) - the mathematical expression to calculate.",
        function=calculator
    )
    
    agent.add_tool(
        name="search",
        description="Searches the web for information. Parameters: 'query' (string) - search query, 'max_results' (string, optional) - number of results.",
        function=search
    )
    
    agent.add_tool(
        name="weather",
        description="Gets current weather for a city. Parameter: 'city' (string) - name of the city.",
        function=weather
    )
    
    agent.add_tool(
        name="translator",
        description="Translates text to target language. Parameters: 'text' (string) - text to translate, 'target_language' (string) - target language name.",
        function=translator
    )
    
    print("=" * 80)
    print("ToolCall Agent Test with Gemini")
    print("=" * 80)
    
    # Test queries
    test_queries = [
        "What is 125 multiplied by 48?",
        "Search for Python programming tutorials",
        "What's the weather in Paris?",
        "Translate 'Hello, how are you?' to Spanish",
        "What is 125 multiplied by 48, and then what's the weather in Paris?",
        "Calculate 100 divided by 5, then search for that number of Python tutorials",
        "What is 50 plus 30, then translate that number to Spanish",
        "who are you"
    ]
    
    results = []
    
    for i, query in enumerate(test_queries, 1):
        print(f"\n\n{'#' * 80}")
        print(f"Test {i}/{len(test_queries)}: {query}")
        print('#' * 80)
        
        try:
            result = agent.invoke(query)
            status = "SUCCESS"
            results.append({
                "test_num": i,
                "query": query,
                "result": result,
                "status": status
            })
            print(f"\n[SUCCESS] Final Answer: {result}")
        except Exception as e:
            import traceback
            status = "FAILED"
            error = str(e)
            results.append({
                "test_num": i,
                "query": query,
                "result": error,
                "status": status
            })
            print(f"\n[ERROR] Error: {error}")
            traceback.print_exc()
        
        print()
    
    # Generate report
    generate_report(results)


if __name__ == "__main__":
    main()
